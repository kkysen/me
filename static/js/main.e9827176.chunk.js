(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[,,,,,,function(e,t,n){e.exports=n.p+"static/media/logo.5d5d9eef.svg"},function(e){e.exports={kkysen:{CAstroParty:{name:"CAstro Party",brief:"TODO",description:"TODO"},MegaMashBros:{brief:"A play on the classic game.",description:"Mega Mash Bros is a clone of Super Smash Bros, developed using libGDX and Java 8 by Stanley Lin and I for our AP Computer Science Spring Final Project in Spring, 2017."},MKS22X:{name:"N Queens",file:"/blob/master/02NQueens/NQueens.java",brief:"A novel solution to a classic computer science problem.",description:"Another one of my passions is re-examining the simple, classic problems of computer science to find new, novel solutions, which can often teach us valuable lessons and techniques that can potentially be applied elsewhere to outstanding effect.  This was the case for my innovative solution to the N Queens problem, which is to count the number of N by N chess boards on which N queens can be placed such that no two queens are threatening each other.  The straightforward way we learned to solve this in school was to create a 2D array as the board and recurse through the rows, placing a queen in the next open spot, and then filling in all the spots threatened by the new queen.  Since the number of solutions grows exponentially, solving the N Queens problem for much higher N is currently impossible, but nevertheless, the simple way we solved it was extremely inefficient, slow, and memory-intensive.  So I set about trying to find a more efficient way to approach the problem.\n\nThe near-optimal solution I developed approached this problem in a fundamentally different way.  Instead of representing the board as a 2D array, I represented the entire board and all the current threats in only three integers.  I used the individual bits of the integers to represent the vertical, left diagonal, and right diagonal threats, allowing me to flip a bit to place a new queen and then bitshift the diagonals to create the next row.  By taking advantage of extremely fast bit operations instead of slower loops, and by confining the memory to only three integers, I was able to run the program entirely on the tiny memory of the CPU instead of accessing comparatively slow RAM.  The result was that my program was thousands of times faster and used dramatically less memory.  Even when I searched online to see if there was a better solution, my program was 20% faster than Jeff Somers\u2019, which purports to be the world\u2019s fastest.  I am currently contacting CS professors to study the ramifications of this work and hopefully apply it to other topics."},Polybius:{brief:"TODO",description:"TODO"},ProjectScheduleViewer:{camelCase:!0,brief:"TODO",description:"TODO"},QuickTrip:{brief:"How to get there fast or cheap.",description:"QuickTrip is the ultimate travel planner.  All you have to do is give it a list of destinations you want to visit and how long and it will plan your entire trip for you.  It will decide the best order of destinations to go to, as well as find the cheapest, highest-rated flights and hotels for you to stay in, and even driving directions between everything.\n\n \n\nQuickTrip was developed by Stanley Lin and I for our AP Computer Science Fall Final Project in Fall, 2016.\n\n \n\nQuickTrip is written in Java 8 using JavaFX and uses many APIs to fetch flight, hotel, and geocoding data, including Google Maps API, Google Maps Directions API, Google Geocoding API, Google QPX Express API, and hotels.com.  It utilizes a caching mechanism for all API requests to avoid going over API rate limits for duplicated requests, the DBSCAN clustering algorithm to find the optimal, clustered destination order, and simulated annealing to find the highest-rated but still cheapest hotels and flights."},r3d3:{brief:"TODO",description:"TODO"},Scramble:{brief:"A challenging word game for your spare time.",description:"My dad has always loved word puzzles, so I created one for him for his birthday: Scramble.  In Scramble, there is a pyramid of letters shown, and the goal is to rearrange all the letters (by clicking on two) such that each row of the pyramid makes its own word.  You can play from size 1 to 20, because at 20 there are very few 20-letter words left.  \n\n \n\nScramble is written using libGDX in Java 8, and although it is only currently setup to run on Java SE, it can be recompiled for deployment on the web, Android, and iOS.\n\n \n\nTo play, click here and download Scramble.jar to your local drive.  Once done, double-click to play."},ScratchWasmRenderer:{brief:"TODO",description:"TODO"},SmartNeuralFuzzer:{brief:"TODO",description:"TODO"}},luojeff:{"aliens-revised":{name:"UFO Tracker",brief:"Let's look for a UFO together.",description:"UFO Tracker is a data analysis project that analyzes UFO reports collected over the past since WWII.  My team, Jeffrey Luo, Max Zlotskiy, Jason Kao, and I, tested if the number of UFO sightings was correlated with the number of nearby flights and even the number of flights flying directly overhead within a few miles of the sighting at the same time.  Surprisingly, we found no correlation between UFO sightings and air traffic.\n\n \n\nUFO Tracker was the winner of the final project competition in Two Sigma's Data Science Workshop in Fall, 2017.  Using Python in a Jupyter Notebook and making heavy use of pandas, we used the UFO reports compiled by the National UFO Reporting Center and available on Kaggle, in addition to flight data, including US aircraft carrier flights, from the Bureau of Transportation Statistics geocoded using the Google Geocoding API."}},tmoi29:{tenaciousTurtles:{name:"Welp",brief:"TODO",description:"TODO"}},wertylop5:{WeatherOrNot:{name:"Weather or Not",brief:"Traffic and weather - to plan your trip better.",description:"Have you ever been looking for driving directions on Google Maps but then realized you didn't want to drive through the pouring rain?  If you have, then Weather Or Not is perfect for you.  It overlays real-time weather maps (and other types of maps) onto a traffic map so that you can have the best of both worlds.  And it even supports adding comments on current conditions to improve the weather and traffic conditions just like Waze.\n\n \n\nWeather Or Not was created during the StuyHacks hackathon in May, 2017 over the course of 24 hours, developed by me, Stanley Lin, Brian Yang, and Aaron Gee.\n\n \n\nWeather Or Not is a pure web app, using HTML, CSS, and plain JS along with APIs like OpenWeatherMap and Firebase for a serverless database.  Currently, it only runs on localhost, but since it's serverless, it can easily be deployed on any domain."}}}},function(e,t,n){e.exports=n.p+"static/media/N Queens Solved.17e9dd48.png"},function(e,t,n){e.exports=n.p+"static/media/N Queens Animation.f968b40c.gif"},function(e,t,n){e.exports=n(19)},,,,,,,function(e,t,n){},function(e,t,n){},function(e,t,n){"use strict";n.r(t);var a=n(1),o=n.n(a),r=n(2),i=n(0),s=n.n(i),l=n(5),c=(n(17),n(18),n(6)),h=n.n(c),d=function(e){var t=e.data,n=t.name,a=t.brief,o=t.url;return i.createElement("div",null,"Name: ",n,"$",a,"See source code: ",i.createElement("a",{href:o},"$",o))},u=function(e){var t=e.data,n=e.children;return i.createElement("div",null,i.createElement(d,{data:t}),n)},p=n(7),f=n(3);function m(e){return e.replace(/([A-Z])/g," $1").trim()}var g,y=(g=p,Object.fromEntries(Object.entries(g).flatMap(function(e){var t=Object(f.a)(e,2),n=t[0],a=t[1];return Object.entries(a).map(function(e){var t=Object(f.a)(e,2),a=t[0],o=t[1];return function(e,t,n){var a=n.brief,o=n.name,r=n.camelCase,i=void 0===r||r,s=n.file;return{name:o||(i?m:function(e){return e})(t),gitHubUser:e,repoName:t,url:"https://github.com/".concat(e,"/").concat(t).concat(s||""),brief:a}}(n,a,o)})}).map(function(e){return[e.repoName,e]}))),b=n(8),w=n.n(b),v=n(9),O=n.n(v),N=function(){var e=y["N Queens"];return i.createElement(u,{data:e},"N Queens solved for N = 8: ",i.createElement("img",{src:w.a}),"N Queens animation for N = 8: ",i.createElement("img",{src:O.a}),"A bitwise solution to the N Queens problem written in Java. Source code at ",e.url,".",i.createElement("video",{src:"https://www.youtube.com/watch?v=b2ejXXoIQqI"}),"Description Another one of my passions is re-examining the simple, classic problems of computer science to find new, novel solutions, which can often teach us valuable lessons and techniques that can potentially be applied elsewhere to outstanding effect. This was the case for my innovative solution to the N Queens problem, which is to count the number of N by N chess boards on which N queens can be placed such that no two queens are threatening each other. The straightforward way we learned to solve this in school was to create a 2D array as the board and recurse through the rows, placing a queen in the next open spot, and then filling in all the spots threatened by the new queen. Since the number of solutions grows exponentially, solving the N Queens problem for much higher N is currently impossible, but nevertheless, the simple way we solved it was extremely inefficient, slow, and memory-intensive. So I set about trying to find a more efficient way to approach the problem. The near-optimal solution I developed approached this problem in a fundamentally different way. Instead of representing the board as a 2D array, I represented the entire board and all the current threats in only three integers. I used the individual bits of the integers to represent the vertical, left diagonal, and right diagonal threats, allowing me to flip a bit to place a new queen and then bitshift the diagonals to create the next row. By taking advantage of extremely fast bit operations instead of slower loops, and by confining the memory to only three integers, I was able to run the program entirely on the tiny memory of the CPU instead of accessing comparatively slow RAM. The result was that my program was thousands of times faster and used dramatically less memory. Even when I searched online to see if there was a better solution, my program was 20% faster than Jeff Somers\u2019, which purports to be the world\u2019s fastest.")},I=window.location,S=Object({NODE_ENV:"production",PUBLIC_URL:"/me"}),T=(S.NODE_ENV,S.PUBLIC_URL,navigator.serviceWorker);!function(){var e=I.hostname;"localhost"!==e&&"[::1]"!==e&&e.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)}();function k(){return A.apply(this,arguments)}function A(){return(A=Object(r.a)(o.a.mark(function e(){var t;return o.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!T){e.next=6;break}return e.next=3,T.ready;case 3:return t=e.sent,e.next=6,t.unregister();case 6:case"end":return e.stop()}},e)}))).apply(this,arguments)}l.render(i.createElement(function(){return s.a.createElement("div",{className:"App"},s.a.createElement("header",{className:"App-header"},s.a.createElement("img",{src:h.a,className:"App-logo",alt:"logo"}),s.a.createElement("p",null,"Edit ",s.a.createElement("code",null,"src/App.tsx")," and save to reload."),s.a.createElement("a",{className:"App-link",href:"https://reactjs.org",target:"_blank",rel:"noopener noreferrer"},"Learn React"),s.a.createElement(N,null)))},null),document.getElementById("root")),Object(r.a)(o.a.mark(function e(){return o.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,k();case 2:case"end":return e.stop()}},e)}))()}],[[10,1,2]]]);
//# sourceMappingURL=main.e9827176.chunk.js.map