{"version":3,"sources":["ts/main/project/ProjectHeader.tsx","ts/main/project/ProjectData.ts","ts/main/project/projectsData.ts","ts/main/writing/WritingData.ts","ts/main/writing/writings.ts","ts/main/page/Writings.tsx","ts/main/project/NQueens.tsx","ts/util/serviceWorker.ts","index.tsx","ts/main/App.tsx","media/N Queens Animation.gif","media/N Queens Solved.png","media/logo.svg"],"names":["ProjectHeader","_ref","data","name","brief","url","react","href","separateCamelCase","className","replace","trim","json","projectsData","projectsJson","Object","fromEntries","entries","flatMap","_ref2","slicedToArray","gitHubUser","repos","map","_ref3","_ref4","repoName","project","_json$camelCase","camelCase","file","s","concat","parseProject","getWritingPaths","docId","make","root","parentDir","dir","metadata","html","src","public","dist","WritingImpl","title","date","classCallCheck","this","writings","writingsMetadata","_ref2$override","override","Date","forEach","writing","console","log","NQueens","style","margin","ProjectHeader_ProjectHeader","solved","animation","location","window","process","serviceWorker","NODE_ENV","PUBLIC_URL","navigator","hostname","match","unRegister","_unRegister","apply","arguments","_callee3","_registration2","regenerator_default","a","wrap","_context3","prev","next","ready","registration","sent","unregister","stop","ReactDOM","react_default","createElement","logo","alt","target","rel","NQueens_NQueens","document","getElementById","asyncToGenerator","mark","_callee","_context","module","exports","__webpack_require__","p"],"mappings":"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","file":"static/js/main.703e5aa8.chunk.js","sourcesContent":["import * as React from \"react\";\nimport {FC} from \"react\";\nimport {ProjectData} from \"./ProjectData\";\n\nexport const ProjectHeader: FC<{data: ProjectData}> = ({data}) => {\n    const {name, brief, url} = data;\n    return <div>\n        Name: {name}\n        <br/>\n        {brief}\n        <br/>\n        See source code: <a href={url}>{url}</a>\n        <br/>\n    </div>;\n};\n","interface ProjectJson {\n    readonly brief: string;\n    readonly name?: string;\n    readonly camelCase?: boolean;\n    readonly file?: string;\n}\n\ninterface ProjectsJson {\n    readonly [gitHubUser: string]: {\n        readonly [repoName: string]: ProjectJson;\n    };\n}\n\nexport interface ProjectData {\n    readonly name: string;\n    readonly gitHubUser: string;\n    readonly repoName: string;\n    readonly url: string;\n    readonly brief: string;\n}\n\nfunction separateCamelCase(className: string): string {\n    return className.replace(/([A-Z])/g, \" $1\").trim();\n}\n\nfunction parseProject(gitHubUser: string, repoName: string, json: ProjectJson): ProjectData {\n    const {brief, name, camelCase = true, file} = json;\n    return {\n        name: name || (camelCase ? separateCamelCase : (s: string) => s)(repoName),\n        gitHubUser,\n        repoName,\n        url: `https://github.com/${gitHubUser}/${repoName}${file || \"\"}`,\n        brief,\n    };\n}\n\nexport function parseProjects(json: ProjectsJson): {[repoName: string]: ProjectData} {\n    return Object.fromEntries(\n        Object.entries(json)\n            .flatMap(([gitHubUser, repos]) => Object.entries(repos)\n                .map(([repoName, project]) => parseProject(gitHubUser, repoName, project))\n            )\n            .map(project => [project.repoName, project])\n    );\n}\n","import projectsJson from \"../../../data/projects/projects.json\";\nimport {parseProjects} from \"./ProjectData\";\n\nexport const projectsData = parseProjects(projectsJson);\n","import axios from \"axios\";\nimport * as fse from \"fs-extra\";\nimport docIDs from \"../../../data/writings/docIDs.json\";\n\nexport interface WritingMetadata {\n    readonly docId: string;\n    readonly title: string;\n    readonly date: Date;\n}\n\nexport interface WritingData extends WritingMetadata {\n    \n    readonly url: string;\n    \n}\n\ninterface WritingPaths {\n    readonly parentDir: string;\n    readonly dir: string;\n    readonly metadata: string;\n    readonly html: string;\n}\n\ninterface AllWritingPaths {\n    readonly src: WritingPaths;\n    readonly public: WritingPaths;\n    readonly dist: WritingPaths;\n}\n\nexport function getWritingPaths(docId: string): AllWritingPaths {\n    const make = (root: string): WritingPaths => {\n        const parentDir = `${root}/data/writings`;\n        const dir = `${parentDir}/${docId}`;\n        return {\n            parentDir,\n            dir,\n            metadata: `${dir}/metadata.json`,\n            html: `${dir}/index.html`,\n        };\n    };\n    return {\n        get src() {\n            return make(\"src\");\n        },\n        get public() {\n            return make(\"public\");\n        },\n        get dist() {\n            return make(\"/me\");\n        },\n    };\n}\n\nclass WritingHtml {\n    \n    constructor(private rawHtml: string) {}\n    \n    private getElement(name: string) {\n        const html = this.rawHtml;\n        const tag = {start: `<${name}>`, end: `</${name}>`};\n        const check = (i: number) => {\n            if (i === -1) {\n                throw new Error(`no ${name}`);\n            }\n            return i;\n        };\n        const startTagStart = check(html.indexOf(tag.start));\n        const endTagStart = check(html.indexOf(tag.end, startTagStart));\n        return html.slice(startTagStart + tag.start.length, endTagStart).trim();\n    }\n    \n    get title(): string {\n        return this.getElement(\"title\");\n    }\n    \n    get date(): Date {\n        const body = this.getElement(\"body\");\n        for (const pattern of [\n            /(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/,\n            /Works Cited.*Web\\. (\\d{1,2} [A-Z][a-z]+\\.? \\d{4})\\./,\n        ]) {\n            const match = pattern.exec(body);\n            if (!match) {\n                continue;\n            }\n            const [_, dateString] = match;\n            const date = new Date(dateString);\n            if (isNaN(date.getTime()) || date.getFullYear() < 2010) {\n                continue;\n            }\n            return date;\n        }\n        console.warn(`can't find date for \"${this.title}\"`);\n        return new Date(); // invalid date\n    }\n    \n    private static endOfHead(): string {\n        return `\n<script>\n    document.body.style.margin = \"10%\";\n</script>`;\n    }\n    \n    get html(): string {\n        const html = this.rawHtml;\n        const tag = \"</body>\";\n        const i = html.lastIndexOf(tag);\n        if (i === -1) {\n            throw new Error(`no ${tag}`);\n        }\n        return [\n            html.slice(0, i),\n            WritingHtml.endOfHead(),\n            html.slice(i),\n        ].join(\"\");\n    }\n    \n}\n\nasync function downloadWriting(docId: string): Promise<WritingMetadata> {\n    const url = `https://docs.google.com/document/d/e/2PACX-${docId}/pub`;\n    const response = await axios.get<string>(url);\n    const {title, date, html} = new WritingHtml(response.data);\n    type Metadata = WritingMetadata & {override?: JsonWritingMetadataOverride};\n    const metadata: Metadata = {docId, title, date};\n    const {src: paths, public: publicPaths} = getWritingPaths(docId);\n    if (await fse.pathExists(paths.dir)) {\n        const oldMetadata: Metadata = await fse.readJson(paths.metadata);\n        metadata.override = oldMetadata.override;\n    }\n    await Promise.all([\n        fse.ensureDir(paths.dir),\n        fse.ensureDir(publicPaths.dir),\n    ]);\n    await Promise.all([\n        fse.writeJson(paths.metadata, metadata),\n        fse.writeFile(paths.html, html),\n        fse.writeFile(publicPaths.html, html),\n    ]);\n    return metadata;\n}\n\nexport async function downloadWritings(): Promise<void> {\n    const writings = await Promise.all(docIDs.map(downloadWriting));\n    writings.sort((a, b) => a.date.getTime() - b.date.getTime());\n    const {src, public: _public} = getWritingPaths(\"\");\n    await Promise.all([src, _public].map(async paths => {\n        await fse.writeJson(`${paths.parentDir}/metadata.json`, writings);\n    }));\n}\n\nclass WritingImpl implements WritingData {\n    \n    readonly docId: string;\n    readonly title: string;\n    readonly date: Date;\n    \n    constructor({docId, title, date}: WritingMetadata) {\n        this.docId = docId;\n        this.title = title;\n        this.date = date;\n    }\n    \n    get url() {\n        return getWritingPaths(this.docId).dist.html;\n    }\n    \n}\n\ninterface JsonWritingMetadata {\n    docId: string;\n    title: string;\n    date: string;\n}\n\ninterface JsonWritingMetadataOverride {\n    title?: string;\n    date?: string;\n}\n\ninterface OverrideableJsonWritingMetadata extends JsonWritingMetadata {\n    override?: JsonWritingMetadataOverride;\n}\n\nexport function writingFromJson({docId, title, date, override = {}}: OverrideableJsonWritingMetadata): WritingData {\n    return new WritingImpl({\n        docId,\n        title: override.title || title,\n        date: new Date(override.date || date),\n    });\n}\n","import writingsMetadata from \"../../../data/writings/metadata.json\";\nimport {WritingData, writingFromJson} from \"./WritingData\";\n\nexport const writings: readonly WritingData[] = writingsMetadata.map(writingFromJson);\n\nwritings.forEach(writing => {\n    console.log(`${writing.title}: ${writing.url}`);\n});\n","import * as React from \"react\";\nimport {FC} from \"react\";\nimport {writings} from \"../writing/writings\";\n\nexport const Writings: FC = () => {\n    return <div>\n        {writings.map(({docId, title, date, url}) => <div key={docId}>\n            {title}\n            <br/>\n            {date.toLocaleDateString()}\n            <br/>\n            <a href={url}>Read it</a>\n            <br/>\n        </div>)}\n    </div>;\n};\n","import * as React from \"react\";\nimport {FC} from \"react\";\nimport animation from \"../../../media/N Queens Animation.gif\";\nimport solved from \"../../../media/N Queens Solved.png\";\nimport {ProjectHeader} from \"./ProjectHeader\";\nimport {projectsData} from \"./projectsData\";\n\nexport const NQueens: FC = () => {\n    const data = projectsData[\"MKS22X\"];\n    return <div style={{margin: \"10%\"}}>\n        <ProjectHeader data={data}/>\n        <br/>\n        N Queens solved for N = 8: <img src={solved}/>\n        <br/>\n        N Queens animation for N = 8: <img src={animation}/>\n        <br/>\n        A bitwise solution to the N Queens problem written in Java.\n        Source code at {data.url}.\n        <video src=\"https://www.youtube.com/watch?v=b2ejXXoIQqI\"/>\n        <br/>\n        Description\n        <br/>\n        Another one of my passions is re-examining the simple, classic problems of computer science to find\n        new, novel solutions, which can often teach us valuable lessons and techniques\n        that can potentially be applied elsewhere to outstanding effect.\n        This was the case for my innovative solution to the N Queens problem,\n        which is to count the number of N by N chess boards on which N queens can be placed\n        such that no two queens are threatening each other.\n        The straightforward way we learned to solve this in school was to create a 2D array as the board\n        and recurse through the rows, placing a queen in the next open spot,\n        and then filling in all the spots threatened by the new queen.\n        Since the number of solutions grows exponentially,\n        solving the N Queens problem for much higher N is currently impossible,\n        but nevertheless, the simple way we solved it was extremely inefficient, slow, and memory-intensive.\n        So I set about trying to find a more efficient way to approach the problem.\n        <br/>\n        The near-optimal solution I developed approached this problem in a fundamentally different way.\n        Instead of representing the board as a 2D array, I represented the entire board\n        and all the current threats in only three integers.\n        I used the individual bits of the integers to represent\n        the vertical, left diagonal, and right diagonal threats,\n        allowing me to flip a bit to place a new queen\n        and then bitshift the diagonals to create the next row.\n        By taking advantage of extremely fast bit operations instead of slower loops,\n        and by confining the memory to only three integers,\n        I was able to run the program entirely on the tiny memory of the CPU\n        instead of accessing comparatively slow RAM.\n        The result was that my program was thousands of times faster and used dramatically less memory.\n        Even when I searched online to see if there was a better solution,\n        my program was 20% faster than Jeff Somers’, which purports to be the world’s fastest.\n        <br/>\n    </div>;\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// data are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst {location} = window;\n\nconst {\n    NODE_ENV: productionMode,\n    PUBLIC_URL: publicUrlString,\n} = process.env;\n\nconst {serviceWorker} = navigator;\n\nconst isLocalHost = (() => {\n    const {hostname} = location;\n    return !!(hostname === \"localhost\" ||\n        // [::1] is the IPv6 localhost address.\n        hostname === \"[::1]\" ||\n        // 127.0.0.1/8 is considered localhost for IPv4.\n        hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n    );\n})();\n\ntype Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n    if (productionMode === \"production\" && serviceWorker) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(publicUrlString, location.href);\n        if (publicUrl.origin !== location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n        \n        window.addEventListener(\"load\", async () => {\n            const swUrl = `${publicUrlString}/service-worker.js`;\n            \n            if (isLocalHost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                await checkValidServiceWorker(swUrl, config);\n                \n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                await serviceWorker.ready;\n                console.log(\"This web app is being served cache-first by a service worker. \" +\n                    \"To learn more, visit https://bit.ly/CRA-PWA\");\n            } else {\n                // Is not localhost. Just register service worker\n                await registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nasync function registerValidSW(swUrl: string, config?: Config) {\n    try {\n        const registration = await serviceWorker.register(swUrl);\n        registration.onupdatefound = () => {\n            const installingWorker = registration.installing;\n            if (installingWorker === null) {\n                return;\n            }\n            installingWorker.onstatechange = () => {\n                if (installingWorker.state === \"installed\") {\n                    if (serviceWorker.controller) {\n                        // At this point, the updated precached content has been fetched,\n                        // but the previous service worker will still serve the older\n                        // content until all client tabs are closed.\n                        console.log(\n                            \"New content is available and will be used when all tabs for this page are closed. \" +\n                            \"See https://bit.ly/CRA-PWA.\");\n                        \n                        // Execute callback\n                        if (config && config.onUpdate) {\n                            config.onUpdate(registration);\n                        }\n                    } else {\n                        // At this point, everything has been precached.\n                        // It's the perfect time to display a\n                        // \"Content is cached for offline use.\" message.\n                        console.log(\"Content is cached for offline use.\");\n                        \n                        // Execute callback\n                        if (config && config.onSuccess) {\n                            config.onSuccess(registration);\n                        }\n                    }\n                }\n            };\n        };\n    } catch (e) {\n        console.error(\"Error during service worker registration:\", e);\n    }\n}\n\nexport async function unRegister() {\n    if (serviceWorker) {\n        const registration = await serviceWorker.ready;\n        await registration.unregister();\n    }\n}\n\nasync function checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    try {\n        const response = await fetch(swUrl);\n        const contentType = response.headers.get(\"content-type\");\n        if (response.status === 404 ||\n            (contentType !== null && !contentType.includes(\"javascript\"))) {\n            // No service worker found. Probably a different app. Reload the page.\n            await unRegister();\n            location.reload();\n        } else {\n            // Service worker found. Proceed as normal.\n            await registerValidSW(swUrl, config);\n        }\n    } catch {\n        console.log(\"No internet connection found. App is running in offline mode.\");\n        return;\n    }\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport \"./css/index.css\";\nimport {OldApp} from \"./ts/main/App\";\nimport * as serviceWorker from \"./ts/util/serviceWorker\";\n\nReactDOM.render(<OldApp/>, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unRegister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n(async () => {\n    await serviceWorker.unRegister();\n})();\n","import React, {FC} from \"react\";\nimport {HashRouter, Route} from \"react-router-dom\";\nimport {Baseball} from \"./page/Baseball\";\nimport {Home} from \"./page/Home\";\nimport {Internships} from \"./page/Internships\";\nimport {Projects} from \"./page/Projects\";\nimport {Resume} from \"./page/Resume\";\nimport {Writings} from \"./page/Writings\";\nimport {NQueens} from \"./project/NQueens\";\nimport \"../../css/App.css\";\nimport logo from \"../../media/logo.svg\";\n\nexport const OldApp: FC = () => {\n    return <div>\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\"/>\n                <p>\n                    Edit <code>src/App.tsx</code> and save to reload.\n                </p>\n                <a\n                    className=\"App-link\"\n                    href=\"https://reactjs.org\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    Learn React\n                </a>\n            </header>\n        </div>\n        \n        <NQueens/>\n    \n    </div>;\n};\n\nconst Header: FC = () => {\n    return <header>\n        Khyber Sen\n    </header>;\n};\n\nconst Footer: FC = () => {\n    return <footer>\n        Email: kkysen@gmail.com\n    </footer>;\n};\n\nexport const App: FC = () => {\n    return <HashRouter>\n        <Header/>\n        <div>\n            <Route exact path=\"/\" component={Home}/>\n            <Route exact path=\"/internships\" component={Internships}/>\n            <Route exact path=\"/projects\" component={Projects}/>\n            <Route exact path=\"/writing\" component={Writings}/>\n            <Route exact path=\"/baseball\" component={Baseball}/>\n            <Route exact path=\"/resume\" component={Resume}/>\n        </div>\n        <Footer/>\n    </HashRouter>;\n};\n","module.exports = __webpack_public_path__ + \"static/media/N Queens Animation.f968b40c.gif\";","module.exports = __webpack_public_path__ + \"static/media/N Queens Solved.17e9dd48.png\";","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}