{"version":3,"sources":["ts/main/page/Baseball.tsx","ts/main/page/Home.tsx","ts/main/page/Internships.tsx","ts/main/project/ProjectHeader.tsx","ts/main/project/ProjectData.ts","ts/main/project/projectsData.ts","ts/main/page/Projects.tsx","ts/main/page/Resume.tsx","ts/main/writing/WritingData.ts","ts/main/writing/writings.ts","ts/main/page/Writings.tsx","ts/main/App.tsx","ts/util/serviceWorker.ts","index.tsx","media/N Queens Animation.gif","media/N Queens Solved.png","media/logo.svg"],"names":["Baseball","react","Home","Internships","ProjectHeader","_ref","data","name","brief","url","href","separateCamelCase","className","replace","trim","json","projectsData","projectsJson","Object","fromEntries","entries","flatMap","_ref2","slicedToArray","gitHubUser","repos","map","_ref3","_ref4","repoName","project","_json$camelCase","camelCase","file","s","concat","parseProject","Projects","values","ProjectHeader_ProjectHeader","key","Resume","getWritingPaths","docId","make","root","parentDir","dir","metadata","html","src","public","dist","WritingImpl","title","date","classCallCheck","this","writings","writingsMetadata","_ref2$override","override","Date","forEach","writing","console","log","Writings","toLocaleDateString","Header","react_default","a","createElement","Footer","location","window","process","serviceWorker","NODE_ENV","PUBLIC_URL","navigator","hostname","match","unRegister","_unRegister","apply","arguments","_callee3","_registration2","regenerator_default","wrap","_context3","prev","next","ready","registration","sent","unregister","stop","ReactDOM","react_router_dom","App_Header","react_router","exact","path","component","App_Footer","document","getElementById","asyncToGenerator","mark","_callee","_context","module","exports","__webpack_require__","p"],"mappings":"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","file":"static/js/main.95e93683.chunk.js","sourcesContent":["import * as React from \"react\";\nimport {FC} from \"react\";\n\nexport const Baseball: FC = () => {\n    return <>\n        Baseball\n    </>;\n};\n","import * as React from \"react\";\nimport {FC} from \"react\";\n\nexport const Home: FC = () => {\n    return <>\n        Home\n    </>;\n};\n","import * as React from \"react\";\nimport {FC} from \"react\";\n\nexport const Internships: FC = () => {\n    return <>\n        Internships\n    </>;\n};\n","import * as React from \"react\";\nimport {FC} from \"react\";\nimport {ProjectData} from \"./ProjectData\";\n\nexport const ProjectHeader: FC<{data: ProjectData}> = ({data}) => {\n    const {name, brief, url} = data;\n    return <div>\n        Name: {name}\n        <br/>\n        {brief}\n        <br/>\n        See source code: <a href={url}>{url}</a>\n        <br/>\n    </div>;\n};\n","interface ProjectJson {\n    readonly brief: string;\n    readonly name?: string;\n    readonly camelCase?: boolean;\n    readonly file?: string;\n}\n\ninterface ProjectsJson {\n    readonly [gitHubUser: string]: {\n        readonly [repoName: string]: ProjectJson;\n    };\n}\n\nexport interface ProjectData {\n    readonly name: string;\n    readonly gitHubUser: string;\n    readonly repoName: string;\n    readonly url: string;\n    readonly brief: string;\n}\n\nfunction separateCamelCase(className: string): string {\n    return className.replace(/([A-Z])/g, \" $1\").trim();\n}\n\nfunction parseProject(gitHubUser: string, repoName: string, json: ProjectJson): ProjectData {\n    const {brief, name, camelCase = true, file} = json;\n    return {\n        name: name || (camelCase ? separateCamelCase : (s: string) => s)(repoName),\n        gitHubUser,\n        repoName,\n        url: `https://github.com/${gitHubUser}/${repoName}${file || \"\"}`,\n        brief,\n    };\n}\n\nexport function parseProjects(json: ProjectsJson): {[repoName: string]: ProjectData} {\n    return Object.fromEntries(\n        Object.entries(json)\n            .flatMap(([gitHubUser, repos]) => Object.entries(repos)\n                .map(([repoName, project]) => parseProject(gitHubUser, repoName, project))\n            )\n            .map(project => [project.repoName, project])\n    );\n}\n","import projectsJson from \"../../../data/projects/projects.json\";\nimport {parseProjects} from \"./ProjectData\";\n\nexport const projectsData = parseProjects(projectsJson);\n","import * as React from \"react\";\nimport {FC} from \"react\";\nimport {ProjectHeader} from \"../project/ProjectHeader\";\nimport {projectsData} from \"../project/projectsData\";\n\nexport const Projects: FC = () => {\n    return <div>\n        {Object.values(projectsData)\n            .map(project => <ProjectHeader data={project} key={project.url}/>)}\n    </div>;\n};\n","import * as React from \"react\";\nimport {FC} from \"react\";\n\nexport const Resume: FC = () => {\n    return <>\n        Resume\n    </>;\n};\n","import axios from \"axios\";\nimport * as fse from \"fs-extra\";\nimport docIDs from \"../../../data/writings/docIDs.json\";\n\nexport interface WritingMetadata {\n    readonly docId: string;\n    readonly title: string;\n    readonly date: Date;\n}\n\nexport interface WritingData extends WritingMetadata {\n    \n    readonly url: string;\n    \n}\n\ninterface WritingPaths {\n    readonly parentDir: string;\n    readonly dir: string;\n    readonly metadata: string;\n    readonly html: string;\n}\n\ninterface AllWritingPaths {\n    readonly src: WritingPaths;\n    readonly public: WritingPaths;\n    readonly dist: WritingPaths;\n}\n\nexport function getWritingPaths(docId: string): AllWritingPaths {\n    const make = (root: string): WritingPaths => {\n        const parentDir = `${root}/data/writings`;\n        const dir = `${parentDir}/${docId}`;\n        return {\n            parentDir,\n            dir,\n            metadata: `${dir}/metadata.json`,\n            html: `${dir}/index.html`,\n        };\n    };\n    return {\n        get src() {\n            return make(\"src\");\n        },\n        get public() {\n            return make(\"public\");\n        },\n        get dist() {\n            return make(\"/me\");\n        },\n    };\n}\n\nclass WritingHtml {\n    \n    constructor(private rawHtml: string) {}\n    \n    private getElement(name: string) {\n        const html = this.rawHtml;\n        const tag = {start: `<${name}>`, end: `</${name}>`};\n        const check = (i: number) => {\n            if (i === -1) {\n                throw new Error(`no ${name}`);\n            }\n            return i;\n        };\n        const startTagStart = check(html.indexOf(tag.start));\n        const endTagStart = check(html.indexOf(tag.end, startTagStart));\n        return html.slice(startTagStart + tag.start.length, endTagStart).trim();\n    }\n    \n    get title(): string {\n        return this.getElement(\"title\");\n    }\n    \n    get date(): Date {\n        const body = this.getElement(\"body\");\n        for (const pattern of [\n            /(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/,\n            /Works Cited.*Web\\. (\\d{1,2} [A-Z][a-z]+\\.? \\d{4})\\./,\n        ]) {\n            const match = pattern.exec(body);\n            if (!match) {\n                continue;\n            }\n            const [_, dateString] = match;\n            const date = new Date(dateString);\n            if (isNaN(date.getTime()) || date.getFullYear() < 2010) {\n                continue;\n            }\n            return date;\n        }\n        console.warn(`can't find date for \"${this.title}\"`);\n        return new Date(); // invalid date\n    }\n    \n    private static endOfHead(): string {\n        return `\n<script>\n    document.body.style.margin = \"10%\";\n</script>`;\n    }\n    \n    get html(): string {\n        const html = this.rawHtml;\n        const tag = \"</body>\";\n        const i = html.lastIndexOf(tag);\n        if (i === -1) {\n            throw new Error(`no ${tag}`);\n        }\n        return [\n            html.slice(0, i),\n            WritingHtml.endOfHead(),\n            html.slice(i),\n        ].join(\"\");\n    }\n    \n}\n\nasync function downloadWriting(docId: string): Promise<WritingMetadata> {\n    const url = `https://docs.google.com/document/d/e/2PACX-${docId}/pub`;\n    const response = await axios.get<string>(url);\n    const {title, date, html} = new WritingHtml(response.data);\n    type Metadata = WritingMetadata & {override?: JsonWritingMetadataOverride};\n    const metadata: Metadata = {docId, title, date};\n    const {src: paths, public: publicPaths} = getWritingPaths(docId);\n    if (await fse.pathExists(paths.dir)) {\n        const oldMetadata: Metadata = await fse.readJson(paths.metadata);\n        metadata.override = oldMetadata.override;\n    }\n    await Promise.all([\n        fse.ensureDir(paths.dir),\n        fse.ensureDir(publicPaths.dir),\n    ]);\n    await Promise.all([\n        fse.writeJson(paths.metadata, metadata),\n        fse.writeFile(paths.html, html),\n        fse.writeFile(publicPaths.html, html),\n    ]);\n    return metadata;\n}\n\nexport async function downloadWritings(): Promise<void> {\n    const writings = await Promise.all(docIDs.map(downloadWriting));\n    writings.sort((a, b) => a.date.getTime() - b.date.getTime());\n    const {src, public: _public} = getWritingPaths(\"\");\n    await Promise.all([src, _public].map(async paths => {\n        await fse.writeJson(`${paths.parentDir}/metadata.json`, writings);\n    }));\n}\n\nclass WritingImpl implements WritingData {\n    \n    readonly docId: string;\n    readonly title: string;\n    readonly date: Date;\n    \n    constructor({docId, title, date}: WritingMetadata) {\n        this.docId = docId;\n        this.title = title;\n        this.date = date;\n    }\n    \n    get url() {\n        return getWritingPaths(this.docId).dist.html;\n    }\n    \n}\n\ninterface JsonWritingMetadata {\n    docId: string;\n    title: string;\n    date: string;\n}\n\ninterface JsonWritingMetadataOverride {\n    title?: string;\n    date?: string;\n}\n\ninterface OverrideableJsonWritingMetadata extends JsonWritingMetadata {\n    override?: JsonWritingMetadataOverride;\n}\n\nexport function writingFromJson({docId, title, date, override = {}}: OverrideableJsonWritingMetadata): WritingData {\n    return new WritingImpl({\n        docId,\n        title: override.title || title,\n        date: new Date(override.date || date),\n    });\n}\n","import writingsMetadata from \"../../../data/writings/metadata.json\";\nimport {WritingData, writingFromJson} from \"./WritingData\";\n\nexport const writings: readonly WritingData[] = writingsMetadata.map(writingFromJson);\n\nwritings.forEach(writing => {\n    console.log(`${writing.title}: ${writing.url}`);\n});\n","import * as React from \"react\";\nimport {FC} from \"react\";\nimport {writings} from \"../writing/writings\";\n\nexport const Writings: FC = () => {\n    return <div>\n        {writings.map(({docId, title, date, url}) => <div key={docId}>\n            {title}\n            <br/>\n            {date.toLocaleDateString()}\n            <br/>\n            <a href={url}>Read it</a>\n            <br/>\n        </div>)}\n    </div>;\n};\n","import React, {FC} from \"react\";\nimport {HashRouter, Route} from \"react-router-dom\";\nimport {Baseball} from \"./page/Baseball\";\nimport {Home} from \"./page/Home\";\nimport {Internships} from \"./page/Internships\";\nimport {Projects} from \"./page/Projects\";\nimport {Resume} from \"./page/Resume\";\nimport {Writings} from \"./page/Writings\";\nimport {NQueens} from \"./project/NQueens\";\nimport \"../../css/App.css\";\nimport logo from \"../../media/logo.svg\";\n\nexport const OldApp: FC = () => {\n    return <div>\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\"/>\n                <p>\n                    Edit <code>src/App.tsx</code> and save to reload.\n                </p>\n                <a\n                    className=\"App-link\"\n                    href=\"https://reactjs.org\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    Learn React\n                </a>\n            </header>\n        </div>\n        \n        <NQueens/>\n    \n    </div>;\n};\n\nconst Header: FC = () => {\n    return <header>\n        Khyber Sen\n    </header>;\n};\n\nconst Footer: FC = () => {\n    return <footer>\n        Email: kkysen@gmail.com\n    </footer>;\n};\n\nexport const App: FC = () => {\n    return <HashRouter>\n        <Header/>\n        <div>\n            <Route exact path=\"/\" component={Home}/>\n            <Route exact path=\"/internships\" component={Internships}/>\n            <Route exact path=\"/projects\" component={Projects}/>\n            <Route exact path=\"/writing\" component={Writings}/>\n            <Route exact path=\"/baseball\" component={Baseball}/>\n            <Route exact path=\"/resume\" component={Resume}/>\n        </div>\n        <Footer/>\n    </HashRouter>;\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// data are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst {location} = window;\n\nconst {\n    NODE_ENV: productionMode,\n    PUBLIC_URL: publicUrlString,\n} = process.env;\n\nconst {serviceWorker} = navigator;\n\nconst isLocalHost = (() => {\n    const {hostname} = location;\n    return !!(hostname === \"localhost\" ||\n        // [::1] is the IPv6 localhost address.\n        hostname === \"[::1]\" ||\n        // 127.0.0.1/8 is considered localhost for IPv4.\n        hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n    );\n})();\n\ntype Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n    if (productionMode === \"production\" && serviceWorker) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(publicUrlString, location.href);\n        if (publicUrl.origin !== location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n        \n        window.addEventListener(\"load\", async () => {\n            const swUrl = `${publicUrlString}/service-worker.js`;\n            \n            if (isLocalHost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                await checkValidServiceWorker(swUrl, config);\n                \n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                await serviceWorker.ready;\n                console.log(\"This web app is being served cache-first by a service worker. \" +\n                    \"To learn more, visit https://bit.ly/CRA-PWA\");\n            } else {\n                // Is not localhost. Just register service worker\n                await registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nasync function registerValidSW(swUrl: string, config?: Config) {\n    try {\n        const registration = await serviceWorker.register(swUrl);\n        registration.onupdatefound = () => {\n            const installingWorker = registration.installing;\n            if (installingWorker === null) {\n                return;\n            }\n            installingWorker.onstatechange = () => {\n                if (installingWorker.state === \"installed\") {\n                    if (serviceWorker.controller) {\n                        // At this point, the updated precached content has been fetched,\n                        // but the previous service worker will still serve the older\n                        // content until all client tabs are closed.\n                        console.log(\n                            \"New content is available and will be used when all tabs for this page are closed. \" +\n                            \"See https://bit.ly/CRA-PWA.\");\n                        \n                        // Execute callback\n                        if (config && config.onUpdate) {\n                            config.onUpdate(registration);\n                        }\n                    } else {\n                        // At this point, everything has been precached.\n                        // It's the perfect time to display a\n                        // \"Content is cached for offline use.\" message.\n                        console.log(\"Content is cached for offline use.\");\n                        \n                        // Execute callback\n                        if (config && config.onSuccess) {\n                            config.onSuccess(registration);\n                        }\n                    }\n                }\n            };\n        };\n    } catch (e) {\n        console.error(\"Error during service worker registration:\", e);\n    }\n}\n\nexport async function unRegister() {\n    if (serviceWorker) {\n        const registration = await serviceWorker.ready;\n        await registration.unregister();\n    }\n}\n\nasync function checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    try {\n        const response = await fetch(swUrl);\n        const contentType = response.headers.get(\"content-type\");\n        if (response.status === 404 ||\n            (contentType !== null && !contentType.includes(\"javascript\"))) {\n            // No service worker found. Probably a different app. Reload the page.\n            await unRegister();\n            location.reload();\n        } else {\n            // Service worker found. Proceed as normal.\n            await registerValidSW(swUrl, config);\n        }\n    } catch {\n        console.log(\"No internet connection found. App is running in offline mode.\");\n        return;\n    }\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport \"./css/index.css\";\nimport {App} from \"./ts/main/App\";\nimport * as serviceWorker from \"./ts/util/serviceWorker\";\n\nReactDOM.render(<App/>, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unRegister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n(async () => {\n    await serviceWorker.unRegister();\n})();\n","module.exports = __webpack_public_path__ + \"static/media/N Queens Animation.f968b40c.gif\";","module.exports = __webpack_public_path__ + \"static/media/N Queens Solved.17e9dd48.png\";","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}